% =============================================================================

\chapter{Background}

Next generation sequencing is a terrific technology.
A wealth of applications have been developed on top of it.
Data analysis pipelines for variant calling and structural variation discovery from DNA-seq, mRNA transcripts abundance estimation and novel non-coding RNA discovery from RNA-seq, transcription factor binding-sites prediction from ChIP-seq.
All these applications rely on a common prerequisite step: mapping NGS reads to a known reference genome.

Read mapping is a critical step in all NGS data analysis pipelines.
NGS reads produced by all current technologies contain sequencing errors, in form of single miscalled bases or stretches of oligonucleotides.
Moreover, the donor genome from which reads have been sequenced contains small genomic variations (SNVs, Indels) in addition to CNV, inversions and translocations.
After all, spotting genomic variation is one reason for which we resequence genomes.
Thus, when mapping a read to a reference genome, it is not sufficient to consider the loci where the reads map exactly; it is necessary to consider any loci of relevant sequence similarity, being possible origins of the sequenced reads.

\section{Sequencing technologies}

\subsection{Illumina}
Illumina / Solexa.

\subsection{Ion Torrent}
Life Technologies / Ion Torrent.

\subsection{454 Life Sciences}
Roche / 454 Life Sciences.

%\subsection{SOLiD}
%ABI / SOLiD.

\section{Sequencing protocols and applications}

\subsection{DNA-seq}
\subsection{RNA-seq}
\subsection{ChIP-seq}

\section{Sequencing quality}

%\subsection{Phred base quality values}

Phred base quality values have been introduced in \citep{Ewing1998, Ewing1998b} to assess the quality of sequencing single bases in capillary reads.
Instead of directly discarding low-quality regions present in capillary reads, Phred calls each base and annotates it with a quality score encoding the probability that it has been wrongly called.
As this method has been widely accepted, base callers annotate reads issue of all sequencing technologies with Phred base quality scores.

To formally define Phred base quality values, let us fix the alphabet $\Sigma = \{$~A,~C,~G,~T~$\}$, and consider a known donor genome $g$ over $\Sigma$ and a read $r$ sequenced at location $l$ from the template $g_{l \dots l+|r|-1}$.
We define the base calling error $\epsilon_i$ at position $i$ in the read $r$, as the probability $\epsilon_i$ of miscalling a base $r_i$ instead of calling its corresponding base $g_{l+i-1}$ in the donor genome.
Therefore, we define the Phred base quality $Q_i$ at position $i$ as:
\begin{eqnarray}
Q_i = -10 \log_{10} \epsilon_i.
\end{eqnarray}

Given the above, the probability $p(r_i | g_{l+i-1})$ of calling the base $r_i$ in the read $r$, given the donor genome base $g_{l+i-1}$, is:
\begin{eqnarray}
p(r_i | g_{l+i-1}) = \left\{
\begin{array}{ll}
1-\epsilon_i                  & \text{ if } g_{l+i-1} = r_i\\
\frac{\epsilon_i}{|\Sigma|-1} & \text{ if } g_{l+i-1} \in \Sigma \setminus \{r_i\}\\
\end{array}
\right.
\end{eqnarray}
and assuming \iid base calling errors, it follows that the probability $p(r | g, l)$ of observing the read $r$, given the donor genome template $g_{l \dots l+|r|-1}$, is:
\begin{eqnarray}
\label{eq:phred}
p(r | g, l) = \prod_{i=1}^{|r|}{p(r_i | g_{l+i-1})}
\end{eqnarray}

% =============================================================================

\section{Mappability}
\label{sec:mappability}

Genome resequencing is a non-trivial task.

The difficulty of unambiguously finding the correct mapping location of next-generation sequencing reads comes from the non-random nature of genomes.
Genomes evolved through multiple types of duplication events, including
\begin{inparaenum}[(i)]
\item whole-genome duplications \citep{?} or large-scale segmental duplications in chromosomes \citep{?},
\item transposition of repetitive elements as short tandem repeats (microsatellites) and interspersed nuclear elements (LINE, SINE) \citep{?},
\item proliferation of repetitive structural elements such as telomeres and centromeres \citep{?}.
\end{inparaenum}
As a result of these events, about 50~\% of the human genome is composed of repeats.

An analysis of the $k$-mer spectra of the genomes of some model organisms shows how genomes are statistically different from texts randomly generated according to uniform bernoulli models.

Repeats present in general technical challenges for all \emph{de novo} assembly and sequence alignment programs \citep{Lee2012}.
In the case of short reads mapping, the first evident effect of the heavy tail in the $k$-mer distribution of reference genomes is the dramatic loss of specificity in certain regions, which increases the computational cost of programs based on filtration methods.
But the most subtle challenge lies in the interpretation of these results: it is not evident how to consider reads mapping to multiple locations.

Common strategies to deal with multi-reads are
\begin{inparaenum}[(i)]
\item to discard them all,
\item to randomly pick one best mapping location,
\item to consider all or up to $k$ best mapping locations within a given distance threshold
\end{inparaenum}
\citep{Treangen2011}.

A practical challenge is represented by reporting and handling the resulting datasets of mapping locations, which can have a size up to two orders of magnitude bigger compared to the corresponding input read sets.

Genome mappability can bias NGS analysis more than we might think at a first glance.
Two recent studies \citep{Derrien2012, Lee2012} show which is the bias of mappability.


% -----------------------------------------------------------------------------

\subsection{Genome mappability}

We now give a definition of genome mappability analogous to \citep{Derrien2012}.
Let fix a $q$-gram length, a distance measure as the Hamming or edit distance, and a distance threshold $k$.
Given a genomic sequence $g$, we define the $(q,k)$-frequency $F^q_k(l)$ of the $q$-gram $g_{l \dots l+q-1}$ at location $l$ in $g$ as the number of occurrences of the $q$-gram in $g$ and its reverse complement $\bar{g}$.
We define the $(q,k)$-mappability $M^q_k(l)$ as the inverse $(q,k)$-frequency, \ie $M^q_k(l) = {F^q_k(l)}^{-1}$ with $M^q_k : \N \rightarrow ]0,1]$.
Note that $M^q_k(l)$ can be seen as the prior probability that any read of length $q$ originating at location $l$ will be mapped correctly.
The values of $(q,k)$-frequency and mappability obviously vary with the distance threshold $k$. Nonetheless, under any distance measure, it hold that the $q$-gram at location $l$ is unique up to distance $k$ iff $M^q_k(l) = 1$ and repeated otherwise.

Which is the minimum $q$-gram length from which we expect $(q,k)$-mappability to be $1$ for the genomes of model organisms?
Let consider the simple case of exact $(q,0)$-mappability.
By assuming a genomic sequence of length $n$ as being randomly generated under the uniform bernoulli model, the emission probability of any nucleotide is $p=\frac{1}{4}$ and, under \iid assumptions, the emission probability of any $q$-gram is $p_q=\frac{1}{4^q}$.
It follows that the expected value of $(q,0)$-frequency is $E[F^q_0] \simeq \frac{2n}{4^q}$.
Thus, for $E[F^q_0] \leq 1$ it must hold:
\begin{eqnarray}
2n \leq 4^q\\
\log{2n} \leq \log{4^q}\\
q \geq log_{4}{2n}
\end{eqnarray}
Thus, we would expect any $q$-gram of length $\log_{4}2n$ to occur about once in a genomic sequence of length $n$.
Sticking to these assumption, in the human genome ($n \approx 3\cdot10^9$) almost all 17-mers would be unique, on fly ($n \approx 1.2\cdot10^8$) all 15-mers, on worm ($n \approx 4.2\cdot10^7$) all 13-mers.
However, the $q$-gram distribution of model genomes does not fit the uniform bernoulli distribution.
In \citep{?} the $k$-mers distribution can be approximated by a double Pareto log-normal distribution, \ie a distribution with a heavy tail.
This is a result of the evolution of genomes being driven by gene duplications, retrotransposons \citep{?}.


Consequently, we would expect 36~bp reads produced by early Illumina sequencers to induce an almost perfect mappability.
However, reads have to be mapped approximately to the reference genome.
The expected number of approximate occurrences of a $k$-mer is higher than the exact one.
Thus the above estimate is a lower bound.

\subsubsection{Uniqueome}

\citeauthor{Derrien2012} quantified the whole genome unique mappability for human, mouse, fly, and worm.
At a $(36,2)$ mapping, about 30~\% of the human genome is not uniquely mappable.
Unique mappability rises to 83~\% by increasing the read length to 75~bp; however to map a significant fraction of the reads, we should consider 3--4 edit distance errors.

\begin{table}[h]
\begin{center}
\caption[Mappability]{Mappability of model genomes. Data extrapolated from \citep{Derrien2012}.}
\input{tables/table_mappability}
\end{center}
\end{table}

The uniqueome plays an important role in ChIP-seq experiments.
It is common practice \citep{?} to rely on short (36~bp) reads and discard the non-unique ones.
Not only a significant fraction of the sequencing data is thrown out.
Worse than that, we end up with holes in 30~\% of the genome.
A ChIP-seq peak caller considering multi-reads calls up to 30~\% more peaks.

Cite regions of clinical relevance, \eg HLA-A.
Cite regions of biological relevance, \eg 5S rRNA.

\subsubsection{Paired-end mappability}

\subsubsection{Pileup mappability}

If we focus our attention to the resequencing accuracy at a single locus, we have to consider the mappability of all the possible reads spanning that given locus.
Pileup mappability \citep{Derrien2012} at position $i$ is the average mappability of all reads spanning position $i$.

$M_p(i) = 1/q \sum_{j=i}^{i+1}{M(j)}$


\subsection{Mapping quality score}
\label{sub:mapqual}

Mapping quality has been introduced in \citep{Li2008}.
The study considers short reads of length ranging from 30~bp to 40~bp, produced by early Illumina/Solexa and ABI/SOLiD sequencing technologies, whose sequencing error rates were quite high.
Given the short lengths and high error rates, a significant fraction of such reads can be aligned to multiple mapping locations, even considering only co-optimal Hamming distance locations.

The key point is that the Hamming distance is not an adequate scoring scheme to guess the correct mapping location of many reads.
The authors claim\footnote{\citeauthor{Li2008} do not show in their study what is the effect of relying on mapping quality rather than on mapping uniqueness.} that:
\begin{quote}It is possible to act conservatively by discarding reads that map ambiguously at some level, but this leaves no information in the repetitive regions and it also discards data, reducing coverage in an uneven fashion, which may complicate the calculation of coverage.\end{quote}
Since base callers output base call probabilities in Phred-scale along with the reads, \citeauthor{Li2008} propose a novel probabilistic scoring scheme called mapping quality, giving the probability that a given read has been aligned correctly at a given mapping location in the reference genome.

By applying Bayes' theorem, we can derive the posterior probability $p(l|g,r)$, that location $l$ in the reference genome $g$ is the correct mapping location of read $r$.
Assuming uniform coverage, each location $l \in [1, |g| - |r| + 1]$ has equal probability of being the origin of a read in the donor genome, thus the prior probability $p(l)$ is simply:
\begin{eqnarray}
p(l) = \frac{1}{|g| - |r| + 1}
\end{eqnarray}
Therefore, recalling $p(r | g, l)$ from equation~\ref{eq:phred}, the posterior probability $p(l|g,r)$ equals the probability of the read $r$ originating at location $l$ normalized over all possible locations in the reference genome:
\begin{eqnarray}
\label{eq:mapprob}
p(l|g,r) = \frac{p(r|g,l)}{\sum_{i=1}^{|g| - |r| + 1}{p(r|g,i)}}
\end{eqnarray}
which in Phred-scale becomes:
\begin{eqnarray}
\label{eq:mapqual}
Q(l|g,r) = -10 \log_{10}[1 - p(l|g,r)]
\end{eqnarray}

Computing the exact mapping quality as in equation~\ref{eq:mapqual} requires aligning each read to all positions in the reference genome.
On one hand, this computation would not be practical, indeed the vast majority of a reference genome is discarded when mapping reads by means of filtering and fully-indexed methods.
On the other hand, the contribution of discarded locations to the sum in equation~\ref{eq:mapprob} can be neglected.
Therefore, equation~\ref{eq:mapprob} is approximated using only relevant mapping locations found by the read mapper.

Mapping quality has been initially used in \citep{Li2008} and \citep{Li2009} to maximize variant calling confidence by discarding reads whose best mapping location is below a given mapping quality threshold.
This measure has been widely accepted: nowadays it is computed by most popular read mappers and used by almost all variant calling pipelines \eg the Genome Analysis ToolKit (GATK) \citep{DePristo2011}.

Nonetheless, some important objections can be moved against mapping quality.
First, the mapping quality score is derived under the unlikely assumption of the reference genome being equal to the donor genome.
In other words, mapping quality considers only errors due to base miscalls and disregards genetic variation; thus the risk is to prefer mapping locations supported by known low base qualities rather than by true but unknown SNVs.
Second, mapping quality is nonetheless strongly correlated to mapping uniqueness, as discussed in section~\ref{sec:mappability}; it is easy to see that the mapping probability in equation~\ref{eq:mapprob} is diluted in presence of a large number of co-optimal mapping locations.
Third, mapping quality tends to become less relevant as base calls improve, due to advances of sequencing technologies, and thus degenerates in a shallow measure of uniqueness.

\subsection{Genome mappability score}

Genome mappability score (GMS) \citep{Lee2012} is analogous to pileup mappability.
Instead of considering the inverse mapping frequency $(q,k)$-mappability, we can interpret mapping quality (see subsection~\ref{sub:mapqual}) as the probability that a read originating at a given position can be mapped correctly. %which is effectively a probabilistic mappability measure,
Therefore, we consider the average mapping probability of any read spanning a location $l$ of a reference genome $g$\footnote{Equation~3 in \citep{Lee2012} is not precise, please refer to our equation~\ref{eq:gms}.}:
\begin{eqnarray}
\label{eq:gms}
p(l|g) = \sum_{r \in \mathcal{R}(l)}{\frac{p(l|g,r)}{|\mathcal{R}(l)|}}
\end{eqnarray}
which in Phread-scale becomes:
\begin{eqnarray}
Q(l|g) = \sum_{r \in \mathcal{R}(l)}{\frac{1 - 10^{-\frac{Q(l|g,r)}{10}}}{|\mathcal{R}(l)|}}
\end{eqnarray}
and thus, fixed a genomic sequence $g$, we define the genome mappability score $\text{GMS}(l)$ as its percentual value:
\begin{eqnarray}
\text{GMS}(l) = 100 Q(l|g)
\end{eqnarray}

\citeauthor{Lee2012} simulate reads having length and error profiles similar to those issue by actual sequencing technologies, define low GMS regions as those locations for which $\text{GMS}(l) \leq 10$, and measure the percentage of such locations in the human genome.

\begin{table}[h]
\begin{center}
\caption[Genome mappability score]{Human genome mappability score of various sequencing technologies. Data extrapolated from \citep{Lee2012}.}
\input{tables/table_gms}
\end{center}
\end{table}

% =============================================================================


\section{Popular read mappers}

Critic the surveys classifying hundreds of mappers \citep{Li2010}, \citep{Fonseca2012}.

Critic the benchmarks \citep{Hatem2013} \citep{Holtgrewe2011}.

The task of a read mapper is to guess where a read originates.
Fixed a similarity scoring scheme that confidently models this problem, the optimal alignment under this scoring scheme correspond to the most likely explanation and induces a locus being the origin of the read.
The simplest scoring scheme is the edit distance; more involved scoring schemes take into account base quality values, score gaps using affine cost functions, or allow to trim for free a prefix or a suffix of the read.

The above definition does not consider two problems: what if there are many co-optimal candidates, and what if the correct solution corresponds to a sub-optimal candidate.
The former problem is exacerbated by genome mappability.
One would expect such situations to arise very rarely, but instead it is a relevant problem.
The latter problem arises whenever our model is not adequate to explain the difference between a read and its genomic origin.
For instance, an evolutionary event producing an indel of length $l$ might be considered as a unit, whether edit distance would consider it as $l$ independent events.
Under the edit distance, an alignment with less than $l$ independent point mutations would be considered more likely than an alignment containing only one indel of length $l$.

From the former problem, we conclude that considering only one optimal mapping location is not sufficient, no matter how good our scoring scheme can be.
The latter problem tells us to be careful about relying on strict optimality.
Therefore, in general a read mapper should return a comprehensive set of relevant mapping locations along with the likelihood that they correspond to the original location.

% -----------------------------------------------------------------------------

\subsection{Bowtie}

Bowtie \citep{Bowtie} is a mapper designed to have a small memory footprint and quickly report a few good mapping locations for early generation Illumina/Solexa and ABI/SOLiD short reads of length up to 50~bp.
It achieves the former goal by indexing the reference genome with an FM-index and the latter goal by performing a greedy depth-first traversal on it.

The greedy depth-first traversal visits first the subtree yielding the least number of mismatches and stops after having found a candidate (not guaranteed to be optimal when $k>1$).
In addition, Bowtie speeds up backtracking by applying case pruning, a simple application of the pigeonhole principle.
However this technique is mostly suited for $k=1$ and requires the index of the forward and reverse text.

Bowtie can be configured to search by strata, however the search time increases significantly while the traversal still misses a large fraction of the search space due to seeding heuristics.
Main practical drawbacks of the tool are too many cryptic options.

Bowtie~2 \citep{Bowtie2} has been designed to quickly report a couple of mapping locations for recent Illumina/Solexa, Ion Torrent and Roche/454 reads, usually having lengths in the range from 100~bp to 400~bp.

This tool uses an heuristic seed-and-extend approach, collecting seeds of fixed length, partially overlapping, and searching them exactly in the reference genome using an FM-index.
Candidate locations to verify are chosen randomly, to avoid uncompressing large CSA intervals and executing many DP instances.
Each mapping location is verified using a striped vectorial dynamic programming algorithm, implemented using SIMD instructions, previously introduced by \citep{Farrar2007} and extended to compute end-to-end alignments.

Bowtie~2 can be configured to report end-to-end or local alignments, scored using a tunable affine scoring scheme.
For this reason, it is believed to be good at reporting alignments containing indels.
However, its completely heuristic filtration strategy, independent of the scoring scheme, makes it hard to believe what it promises.

% -----------------------------------------------------------------------------

\subsection{BWA}

BWA-backtrack \citep{BWA} is designed to map Illumina/Solexa reads up to 100~bp and report a few best end-to-end alignments.
The program performs a greedy breadth-first search on an FM-index of the reference genome.
Nodes to be visited are ranked by edit distance score: the best node is popped from a priority queue and visited, its children are then inserted again in the queue.
The traversal considers indels using a more involved 9-fold recursion.
Backtracking is sped up by adopting a more stringent pruning strategy that nonetheless takes some preprocessing time and requires the index of the reverse reference genome.

BWA performs paired-end alignments by trying to anchor both paired-end reads and verifying the corresponding mate, within an estimated insert size, using the classic DP-based Smith-Waterman algorithm.
Consequently, the program in paired-end mode aligns reads at a slower rate than in single-end mode.
The program is not fully multi-threaded, therefore BWA scales poorly on modern multi-core machines.

BWA-SW \citep{BWA-SW} is designed to map Roche/454 reads, which have an average length of 400~bp.
It is an heuristic version of BWT-SW, designed to report a few good local alignments.

This version of BWA adopts a double indexing strategy: it indexes all substrings of one read in a DAWG.
It performs Smith-Waterman of all read substrings directly on the FM-index, by backtracking as soon as no viable alignment can be obtained.
As in BWA-backtrack, the traversal proceeds in a greedy fashion.
In addition, BWA-SW implements some seeding heuristics to limit backtracking and jump in the reference genome to verify candidate locations whenever this becomes favorable.

This version of BWA does not support paired-end reads, presumably because it was meant for Roche/454 reads.

% -----------------------------------------------------------------------------

\subsection{Soap}

Soap~2 \citep{Soap2} is very similar to Bowtie: it has been designed to produce a very quick but shallow mapping of Illumina/Solexa reads up to 75~bp with no more than 2 mismatches and no indels.
However, its underlying algorithm is based on the so-called bi-directional (or 2-way) BWT.
The tool support paired-end mapping but at a slower alignment rate.
Practical drawbacks are the lack of native output in the de-facto standard SAM format and is closed source.
Soap~3 \citep{Soap3} is algorithmically similar to Soap~2 but targets only NVIDIA CUDA accelerators.

% -----------------------------------------------------------------------------

\subsection{SHRiMP}

SHRiMP~2 TODO.

% -----------------------------------------------------------------------------

\subsection{RazerS}

RazerS \citep{Weese2009} has been designed to report all mapping locations within a fixed hamming or edit distance error rate.
It is based on a full-sensitive $q$-gram filtration method (SWIFT semi-global) combined with the Myers edit distance verification algorithm.
On demand, the SWIFT filter can be configured to become lossy within a fixed loss rate.
The lossy filter becomes more stringent and produces a lower number of candidates to verify, thus improving the overall speed of the program.
All in all, the SWIFT filter is very slow while not highly specific.

RazerS~3 \citep{RazerS3} is a faster version featuring shared-memory parallelism, a faster banded-Myers verification algorithm, and a faster filtration scheme based on exact seeds that however turns out to be very weak on mammal genomes.
Because of this, RazerS~3 is one-two orders of magnitude slower than Bowtie~2 and BWA-backtrack on mammal genomes.

All RazerS versions index the reads and scan the reference genome.
One positive aspect of this strategy is that no preprocessing of the reference genome is required.
However, other mapping strategies beyond all-mapping, \eg mapping by strata, cannot be efficiently implemented.
Moreover, the program exhibit an high memory footprint as it must remember the mapping locations of all input reads until the whole reference genome has been scanned.

% -----------------------------------------------------------------------------

\subsection{mr(s)Fast}

The tools mrFast \citep{Ahmadi2011} and mrsFast \citep{Hach2010} are designed to report all mapping locations within a fixed absolute number errors, respectively under the hamming and edit distance, given Illumina/Solexa reads of length ranging from 50~bp to 125~bp.
Similarly to RazerS~3, they are based on a full-sensitive filtration strategy using exact seeds, which turns out to be very weak on mammal genomes.

The peculiarity of their underlying method is a cache-oblivious strategy to mitigate the high cost of verifying clusters of candidate locations.
In addition, mrsFast computes the edit distance between one read and one mapping location in the reference genome with an antidiagonal-wise vectorial dynamic programming algorithm, implemented using SIMD instructions.

These tools are as slow as RazerS~3 and appealing for nothing more than all-mapping.
They lack multi-threading support and exhibit various bugs.
Furthermore, they only accept reads of fixed length and produce files of impractical size.

% -----------------------------------------------------------------------------

\subsection{GEM}

The GEM mapper \citep{Gem} is a flexible read aligner for Illumina/Solexa, ABI/SOLiD, and Ion Torrent reads.
It is full-sensitive and can be configured either as an all-mapper, as a best/unique-mapper, or to search by strata.

GEM uses a combination of state of the art approximate string matching methods, \eg approximate seeds and suffix filters.
The program indexes the reference genome with an FM-index, tries to find an optimal filtration strategy per read, and verifies candidate locations using Myers algorithm.
Paired-reads are either mapped independently and then combined, or left/right are mapped and their mates verified using an online strategy.

Unfortunately the tool lacks direct SAM output, it is not open source, and provides many obscure parameters.

% -----------------------------------------------------------------------------

\subsection{Masai and Yara}

% -----------------------------------------------------------------------------

\begin{landscape}
\begin{table}[h]
  \center
  \sffamily
%  \resizebox{1.0\textwidth}{!}
%  {
	\renewcommand{\tabcolsep}{0.8ex}
	\input{tables/table_mappers}
%  }
\end{table}
\end{landscape}

% =============================================================================

\chapter{Masai}

In this chapter we present our first attempt to engineer an efficient all-mapper.
When we started this project, in October 2011, the fastest all-mappers (MrFast and RazerS~3) were two order of magnitude slower than prominent best-mappers (Bowtie and BWA).
On one hand, all-mappers were using filtration based on exact seeds, which is fine for short reference genomes but becomes too weak for mammal genomes; clearly, a stronger filtration strategy would had been beneficial.
On the other hand, best-mappers were based on heuristic backtracking, which was becoming inadequate to map reads of increasing length.
After a thorough literature review, we came out with a novel read mapping method combining seed-based filtering with backtracking.

In the engineering section, we explain which data structures we adopt for indexing, how our filtration method works, and how we perform seed extension.
In particular, our filtration method is based on exact or approximate seeds;
we obtain a stronger filter for mammal genomes, which is still non-heuristic and full-sensitive, by employing approximate seeds instead of exact seeds.
We find approximate seeds by backtracking the index of the reference genome.
Moreover, we speed up the backtracking phase by searching all seeds simultaneously, with the help of an additional index and the multiple backtracking algorithm.
Lastly, we improve our method to perform best-mapping in a more efficient way.

Our method is packaged in a \CC tool nicknamed \emph{Masai}, which stands for \emph{m}ultiple backtracking of \emph{a}pproximate \emph{s}eeds on a suffix \emph{a}rray \emph{i}ndex.
Masai is part of the SeqAn library, it is distributed under the BSD license and can be downloaded from \url{http://www.seqan.de/projects/masai}.

In the evaluation section, we extensively compare Masai with popular read mappers, both on simulated and real datasets.
Compared to MrFast and RazerS~3, Masai is an order of magnitude faster and has comparable sensitivity.
In addition, Masai is more accurate and 2--4 times faster than Bowtie\,2 \citep{Bowtie2} and BWA \citep{BWA}.

Finally, we discuss the limitations of Masai that led us to engineer Yara, yet another read aligner.

% -----------------------------------------------------------------------------

\section{Engineering}

Here we give an overview of the process to map reads to a reference genome.

We first construct a conceptual \emph{suffix tree} of the reference genome, then store it on disk and reuse it for each read mapping job.
Any data structure equivalent to the generalized suffix tree in terms of allowing a top-down traversal can be used to this intent. We implemented a generic algorithm using the suffix array \citep{Manber1990}, the enhanced suffix array \citep{Abouelhoda2004}, and the FM-index \citep{Ferragina2001}.

At mapping time we choose a filtration strategy according to the reference genome and the specified absolute number of errors.
Our filtration strategies are based on \citep{Navarro2000}, make use of \emph{exact and} approximate non-overlapping seeds and are guaranteed to be full-sensitive by the pigeonhole principle.
In Figure~\ref{fig:FiltrationStrategies} we show an example providing two alternative filtration strategies.

Therefore we partition all reads and their reverse complements in non-overlapping seeds and subsequently arrange all seeds in a conceptual \emph{radix tree}.
The time spent to construct the radix tree is easily justified, since this additional index allows us to perform backtracking more efficiently.
We indeed apply our \emph{multiple backtracking algorithm}, in order to search simultaneously all seeds in the suffix tree of the reference genome.

Finally we perform seed extension on each seed reported by the multiple backtracking algorithm.
We extend both ends of each seed using a banded version of \emph{Myers bit-vector algorithm} \citep{Myers1999},  already adopted in \citep{Razers3}.

In the following of this section we give a detailed explanation of each mapping step.

\subsection{Indexing}

We implemented a generic suffix tree top-down traversal on the \emph{suffix array} \citep{Manber1990}, the \emph{enhanced suffix array} (Esa) \citep{Abouelhoda2004}, and the \emph{FM-index} \citep{Ferragina2001}.
The Esa preserves the asymptotic performances of the suffix tree and consumes, as implemented in SeqAn, $13n$ bytes for a sequence of length $n$.
Nevertheless, the suffix array, despite consuming $5n$ bytes and being theoretically slower, always showed better performance than the Esa (Supplementary Data).
The FM-index implicitly represents a prefix trie in only $1.5n$ bytes and provides constant time node traversal, while being slower than the other two data structures.

\subsubsection{Indexing the reference genome}

We prefer the suffix array because it provides a good compromise between speed and memory consumption, but nevertheless leave the possibility to choose among the aforementioned data structures.
We construct the (generalized) suffix array using an adaptation of the DC7 algorithm \citep{Dementiev2008} to multiple sequences.
For construction of the Esa or FM-index we additionally use the algorithms proposed in \citep{Kasai2001,Abouelhoda2004} and \citep{Grossi2003}.
Similarly to all read mappers relying on an index of the reference genome, we build the index of the reference genome only once, store it on disk, and reuse it for each mapping job.

\subsubsection{Indexing the reads}

We implemented a lazy radix tree based on the \emph{wotd}-algorithm \citep{Giegerich1999}, since a radix tree is a partial suffix tree only containing certain suffixes. The radix tree is constructed in linear time by subsequent radix sort steps.
However, when performing multiple backtracking with exact seeds, the radix tree construction time dominates the overall filtration time.
Therefore in this case we resort to the \emph{$q$-gram index} to emulate the radix tree.
We build the $q$-gram index efficiently and in linear time by bucket sort.
Below depth $q$ the properties of the radix tree are lost, however multiple backtracking is still applicable.
%We observed that the $q$-Gram index is more convenient than the lazy suffix tree for exact search.

\subsection{Seeding}
%Refer to exact and approximate seeds

We now consider formally the read mapping problem.
Given a reference genome $g$, a set of reads $\mathcal{R}$ and an absolute number of errors $k$ consisting of indels and mismatches, for each read $r \in \mathcal{R}$ find all mapping locations where $r$ approximately occurs in $g$ within $k$ errors.

Filtration specificity in terms of candidate locations to verify is strongly correlated to seed length.
Since we want to maximize the length of the shortest seed, we let the minimum seed length be $\lfloor |r|/(k+1) \rfloor$.
If we want to improve filtration specificity by increasing seed length, we resort to approximate seeds.

We partition $r$ into $s \leq k+1$ non-overlapping seeds.
According to the pigeonhole principle each approximate occurrence of $r$ in $g$ then contains an approximate occurrence of some seed within distance $\lfloor k/s \rfloor$.

%Moreover, since the number of seeds within distance $\lfloor k/s \rfloor$ is $s - (k \bmod s)$,
Moreover, we search $(k \bmod{s}) + 1$ seeds within distance $\lfloor k/s \rfloor$ and the remaining seeds within distance $\lfloor k/s \rfloor - 1$.
To prove full-sensitivity it suffices to see that, if none of the seeds occurs within its assigned distance, the total distance must be at least $s \cdot \lfloor k/s \rfloor + (k \bmod s) + 1 = k + 1$.
Hence all approximate occurrences of $r$ in $g$ within distance $k$ will be found.

With approximate seeds we are free to choose the number of seeds $s$, which in turn enforces the minimum seed length $l$ to be $\lfloor |r|/s \rfloor$.
Or vice versa we fix $l$, which enforces $s$ to be $\lfloor |r|/l \rfloor$.
The resulting filter is flexible, indeed by increasing $l$ filtration becomes more specific at the expense of a higher filtration time.

The optimal seed length $l$ depends on the reference genome as well as on read length and the absolute number of errors.
When mapping current NGS datasets on short to medium length genomes, \eg bacterial genomes, exact seeds are still more efficient than approximate seeds.
Conversely on larger genomes, \eg mammalian genomes, approximate seeds outperform exact seeds by an order of magnitude.

In Masai Algorithm~\ref{MultipleApproximateSearch} is implemented only for mismatches, consequently full-sensitivity is not attained when using approximate seeds and considering mapping locations with indels.
However in the results section we show that such implementation detail sacrifices less than 1\% sensitivity.

\subsection{Seed extension}

We use a banded version of Myers bit-vector algorithm \citep{Myers1999} already presented in \citep{Razers3}.
Myers' algorithm is an efficient DP alignment algorithm \citep{Needleman1970} for edit distance. 
Instead of computing DP cells one after another, it encodes the whole DP column in two bit-vectors and computes the adjacent column in a constant number of 12 logical and 3 arithmetical operations.
We implemented a bit-parallel version that computes only a diagonal band of the DP matrix and is faster and more specific than the original algorithm by Myers.
More details can be found in the Supplementary Data.

However differently from \citep{Razers3}, instead of performing a semi-global alignment to verify a parallelogram surrounding the seed, we perform a global alignment on both ends of a seed.
Given a seed occurring with $e$ errors, we first perform seed extension on the left side within an error threshold of $k - e$ errors.
Only if the seed extension on the left side succeeds, we perform a seed extension on the right side within the remaining error threshold.
Moreover, we first compute the longest common prefix on each side of the seed and let the global alignment algorithm start from the first mismatching positions.
We observed that this approach is up to two times faster than \citep{Razers3}.

\subsection{Best-mapping}

% -----------------------------------------------------------------------------

\section{Evaluation}

We thoroughly compared Masai with the best-mappers Bowtie\,2, BWA and Soap\,2 as well as with the all-mappers RazerS\,3, Hobbes, mrFAST and SHRiMP\,2.
We remark that Bowtie\,2, BWA, Soap\,2 and SHRiMP\,2 rely on scoring schemes taking into account base quality values, while Masai, RazerS\,3, Hobbes and mrFAST use edit distance.
When relevant, read mappers that accept an absolute number of errors (Masai, mrFAST, Hobbes, Soap\,2) or an error rate (RazerS\,3) were configured accordingly.
We used default parameters, except where stated otherwise (Supplementary Data).

We performed runtime experiments on real data.
All read sets are given by their SRA/ENA id.
As references we used whole genomes of E.~coli (NCBI NC\_000913.2), C.~elegans (WormBase WS195), D.~melanogaster (FlyBase release 5.42), and H.~sapiens (GRCh37.p2).
The mapping times were measured on a cluster of nodes with 72\,GB RAM and 2 Intel Xeon X5650 processors running Linux~3.2.0.
For running time comparison, we ran the tools using a single thread and used local disks for I/O.

\subsection{Read mappers parametrization}

In the following, we describe how we configured all read mappers considered in the evaluation section.
%\texttt{MIN} and \texttt{MAX} were placeholders for minimal and maximal insert size, \texttt{INS} is the mean insert size and \texttt{IERR} the allowed deviation (\texttt{INS = (MIN + MAX) / 2}, \texttt{ERR = (MAX - MIN) / 2}).

\paragraph{Masai}
Version 0.5 was used.
In order to use Masai as an all-mapper we passed the argument \texttt{--all}, otherwise the argument \texttt{--any-best} is used by default.
We set the maximal edit distance using the parameter \texttt{-e}.
We configured the seed length with the parameter \texttt{--seed-length}; on E.~coli, D.~melanogaster and C.~elegans we chose a seed length of $16$, while on H.~sapiens we chose a seed length of $33$.
We selected the SAM output format with \texttt{-os} and enabled CIGAR output with \texttt{-oc}.

\paragraph{Bowtie\,2}
Version 2.0.0-beta6 was used.
We used the parameter \texttt{--end-to-end} to enforce semi-global read alignments.
For the Rabema benchmark we used the parameter \texttt{-k 100}.
%In paired-end mode, we used the parameters \texttt{--minins MIN --maxins MAX}.
%The number of threads was selected using the parameter ({\tt -p}).

\paragraph{BWA}
Version 0.6.1-r104 was used.
For the Rabema experiment we passed the parameter \texttt{-N} to \texttt{aln} and \texttt{-n 100} to \texttt{samse}.
%The insert size was not passed to BWA, however we pass the insert size and allowed error from BWA's output to the other read mappers.
%We used the parameter \texttt{-t} to select the number of threads in the \texttt{aln} step.
%The {\tt sampe} and {\tt samse} steps were performed using one thread since BWA does not offer a paralellization here.

\paragraph{Soap\,2}
Version 2.1 was used.
%The number of threads was selected with \texttt{-p}.
%In paired-end mode, the options used are \texttt{-m MIN -x MAX}.

\paragraph{RazerS\,3}
Version 3.1 was used.
We mapped with indels using the pigeonhole filter (default) and set the error rate through the parameter \texttt{-i}, \eg \texttt{-i 95} to map within an error rate of 5\,\%.
We selected the native or SAM output format with \texttt{-of 0} or \texttt{-of 4}.
%In paired-end mode, the parameters used were \texttt{--library-length INS --library-error IERR}.
%The number of threads was set with the \texttt{-tc} parameter.

\paragraph{Hobbes}
Version 1.3 was used.
We built the index using the recommended
%\footnote{\url{http://hobbes.ics.uci.edu/manual.jsp}}
$q$-gram length 11.
Since we focus on edit distance, we used the 16\,bit bit-vector version.% as described in~\citep{Ahmadi2011}. 
We enabled indels with \texttt{--indels} and set maximal edit distance using the parameter \texttt{-v}.
For resource measurement we used the output without CIGAR, for analyzing the results we enabled CIGAR output using \texttt{--cigar}.
%In paired-end mode, we used the parameters \texttt{--pe --min MIN --max MAX}.
%Multi-threading was enabled using \texttt{-p}.

\paragraph{mrFAST}
Version 2.1.0.6 was used.
%It was used as explained in the manual\footnote{\url{http://mrfast.sourceforge.net/manual.html}}.
We set maximal edit distance using the parameter \texttt{-e}.
%mrFAST does not support multithreading.
%We divided the input into blocks of 500\,k reads and processed each chunk in a separate process using the program \texttt{ts}\footnote{\url{http://vicerveza.homeunix.net/~viric/soft/ts/}}.
%Long reads were split into packages of 100\,k reads.
%This way, always 8 processes were executed in parallel.

\paragraph{SHRiMP\,2}
Version 2.2.2 was used.
%The number of threads was selected with \texttt{--threads}.
%In paired-end mode, the options used are \texttt{--pair-mode opp-in --isize MIN,MAX}.

\subsection{Rabema}

We first used the Rabema benchmark~\citep{Holtgrewe2011} (v1.1) for a thorough evaluation and comparison of read mapping sensitivity.
Similarly to \citep{Bowtie2}, we used the read simulator Mason \citep{SeqAnReadSimulator} with default profile settings to simulate from each whole genome 100\,k reads of length 100\,bp having sequencing errors distributed like in a typical Illumina run (Supplementary Data).

The benchmark contains the categories \emph{all}, \emph{all-best}, \emph{any-best}, \emph{precision}, and \emph{recall}.
In the categories all, all-best, and any-best a read mapper had to find all, all of the best, or any of the best edit distance locations for each read.
The categories precision and recall required a read mapper to find the \emph{original} location of each read, which is a measure independent of the used scoring model, \eg edit distance or quality based.
A read is mapped \emph{correctly} if the mapper reported its original location, 
and it is mapped \emph{uniquely} if the mapper reported only one location.
Rabema defines \emph{recall} to be the fraction of reads which were correctly mapped and \emph{precision} the fraction of uniquely mapped reads that were mapped correctly.

The benchmark was performed for an error rate of 5\,\%, which corresponds to edit distance 5 for reads of length 100\,bp. Therefore we built a Rabema gold standard for each dataset by running RazerS~3 in full-sensitive mode up to edit distance 5. We further classified mapping locations in each category by their edit distance.

For a more fair and thorough comparison we also configured BWA and Bowtie\,2 as all-mappers (Soap\,2 could not be configured accordingly).
To this extent, we parametrized them to be highly sensitive and output all found mapping locations.
Since BWA and Bowtie\,2 were not designed to be used as all-mappers, they spent much more time than proper all-mappers, \ie up to 3~hours in a run compared to several minutes.
The aim here is to investigate read mapping sensitivity and therefore we do not report running times.

Results for H.~sapiens are shown in Table~\ref{tab:Rabema}.
Additional results for E.~coli, C.~elegans and D.~Melanogaster are shown in the Supplementary Data.

\subsubsection{Best-mappers}
Masai showed the best recall values, not loosing more than 3.3\,\% recall on edit distance 5.
Conversely, recall values of BWA and Bowtie\,2 dropped significantly with increasing edit distance up to loosing respectively 15.4\,\% and 11.5\,\% on edit distance 5.
As expected, Soap\,2 turned out to be inadequate for mapping reads of length 100\,bp at this error rates.

Precision values have less variance than recall values. Masai showed the best precision values with 97.8\,\%, followed by Soap\,2 with 97.7\,\%, and BWA with 97.5\,\%. Interestingly, Bowtie\,2 showed the worst precision values, loosing up to 5.6\,\% on edit distance 5.
%Interestingly, Rabema any-best values provide a quite tight upper bound to recall values.
%We deduce that edit distance is a pertinent and adequate scoring scheme for read mapping.
%Vice versa, scoring schemes based on quality values as well as the heuristics on which other best-mappers rely lead to a generalized and substantial loss of mapping accuracy.

\subsubsection{All-mappers}
As expected, RazerS\,3 showed full-sensitivity and mrFAST lost only a minimal percentage of mapping locations.
Overall Masai did not loose more than 0.1\,\% of all mapping locations.
In particular, Masai was full-sensitive for low-error locations and it lost only a small percentage of high-error locations, \ie its loss was limited to 0.1\,\% and 1.4\,\% of mapping locations at edit distance 4 and 5.

On the other side, BWA and Bowtie\,2 missed 35\,\% and 45\,\% of all mapping locations at edit distance 5 and their recall values as all-mappers did not substantially increase.
Likewise SHRiMP\,2 could not enumerate all mapping locations, although its recall values were good.
Again Hobbes had the worst performance.

We remark that Masai is not full-sensitive whenever approximate seeds are used, \eg on H.~sapiens. Indeed, Masai lost 0.1\,\% overall sensitivity in respect to RazerS\,3. Conversely, full-sensitivity is attained whenever exact seeds are used, \eg on E.~coli, C.~elegans and D.~Melanogaster (Supplementary Data).
In general, RazerS\,3 should be used when full-sensitivity is required, \ie for read mapper benchmarking. However, our results show that Masai can replace RazerS\,3 or mrFAST as an all-mapper in practical setups.

\begin{table*}[t]
  \caption[Rabema results]
  {
  \label{tab:Rabema}
    {\bfseries Rabema results.}
    Rabema scores in percent
    (average fraction of edit distance locations reported per read).
    Large numbers show total scores in each Rabema category and small numbers show the category scores separately for reads with $\bigl(\begin{smallmatrix}\mbox{\tiny 0}&\mbox{\tiny 1}&\mbox{\tiny 2}\\\mbox{\tiny 3}&\mbox{\tiny 4}&\mbox{\tiny 5}\end{smallmatrix}\bigr)$ errors.
    }
  \vspace{-3mm}
  \center
  \sffamily
  \resizebox{0.95\textwidth}{!}
  {
	\renewcommand{\tabcolsep}{0.8ex}
	\input{tables/table_masai_rabema}
  }
\end{table*}

\subsection{Variant detection}

The second experiment analyzes the applicability of Masai and other read mappers in genomic variation pipelines.
Similarly to \citep{Shrimp2}, we simulated from the whole human genome 5 million reads of length $100$\,bp containing sequencing errors, SNPs and indels such that each read had an edit distance of at most 5 to its genomic origin.
To distribute sequencing errors according to a typical Illumina run, we used the read simulator Mason.
The reads were grouped according to the numbers of contained SNPs and indels, where the class $(s,i)$ consists of all reads with $s$ SNPs and $i$ indels.
We mapped the reads with each tool and measured its sensitivity in each class.

We say that a read is mapped \emph{correctly} if a mapping location has been reported within 10\,bp of its genomic origin.
It is considered to map \emph{uniquely} if only one location was reported by the mapper.
For each class we define \emph{recall} to be the fraction of reads which were correctly mapped and \emph{precision} the fraction of uniquely mapped reads that were mapped correctly.
Table~\ref{tab:Variant} shows the results for each read mapper and class.

\subsubsection{Best-mappers}
Among best-mappers, Masai showed the highest precision and recall in all classes.
In particular, Masai did not loose more than 3.2\,\% recall in class (4,0), whether Bowtie\,2 and BWA lost respectively 17.5\,\% and 14.9\,\% and Soap\,2 was not able to map any read.

Interestingly, we observed that recall values of Bowtie\,2, BWA and Soap\,2 were negatively correlated with the amount of genomic variation.
For instance, in the Rabema benchmark Bowtie\,2 lost respectively 7.2\,\% and 11.5\,\% of mapping locations at distance 4 and 5, but in this experiment it lost 17.5\,\% recall in class (4,0).
We noticed a similar trend for BWA and Soap\,2.
%We deduced that Bowtie\,2, BWA and Soap\,2 are not well suited to reliably detect the origin of reads with variants. Indeed 
These tools rely on quality values to guess the best mapping location for a read and tend to prefer alignments which can be explained by sequencing errors instead of true genomic variations.
The low performance of Soap\,2 is also due to its limitation to at most 2 mismatches and no support for indels.

\subsubsection{All-mappers}
Looking at all-mappers results, Masai showed 100\,\% precision and recall in all classes, except for classes (2,0) and (1,1) where it lost only 0.1\,\% and 0.7\,\% recall.
Masai is therefore roughly comparable to the full-sensitive read mappers RazerS\,3 and mrFAST.
SHRiMP\,2 showed 100\,\% precision in all classes but lost between 0.3\,\% and 0.8\,\% recall in each class.
Hobbes had the lowest performance among all-mappers.
It appears to have problems with indels, indeed it lost 9.5\,\% recall in class (0,3).

\begin{table*}[tH!]
  \caption[Variant detection results]
  {
  \label{tab:Variant}
    {\bfseries Variant detection results.} We show the percentages of found origins (recall) and fraction of unique reads mapped to their origin (precision) classed by reads with $s$ SNPs and $i$ indels $(s,i)$.
  }
  \vspace{-3mm}
  \center
  \sffamily
  \resizebox{0.8\textwidth}{!}
  {
	\renewcommand{\tabcolsep}{0.8ex}
	\input{tables/table_masai_variant}
  }
\end{table*}

\subsection{Performance on real data}

In the last experiment we focused on comparing read mappers performance on real data.
To this end, we mapped the first $10\,\text{M}\times 100\,\text{bp}$ reads from an Illumina lane of E.~coli (ERR022075, Genome Analyzer IIx), D.~melanogaster (SRR497711, HiSeq 2000), C.~elegans (SRR065390, Genome Analyzer II), and H.~sapiens (ERR012100, Genome Analyzer II).
In order to measure scalability, we also mapped the full $60\,\text{M}\times 100\,\text{bp}$ (ERR012100) and $150\,\text{M}\times 100\,\text{bp}$ (ERR161544, HiSeq 2000) H.~sapiens datasets.
Whenever possible we asked mappers to map reads within edit distance 5.
We measured running times, peak memory consumptions, mapped reads and Rabema any-best scores.

We could not measure precision and recall values since real reads have unknown origins. Therefore for the evaluation we adopted the commonly used measure of percentage of \emph{mapped reads}, \ie the fraction of reads for which the read mapper reports a mapping location.
However, as some mappers report mapping locations without constraints on the number of errors, we also included Rabema \emph{any-best} scores.
The Rabema any-best benchmark assigns a point for a read if the mapper reports at least one mapping location with the optimal (minimum) number of errors.
Final Rabema any-best scores are normalized by the number of reads.

It should be noted, that in this evaluation we are interested on the capability of the mapper to retrieve the location of a single read without the help of read pairs, which can of course disambiguate mapping locations of the partner.

Results for C.~elegans and H.~sapiens are shown in Table~\ref{tab:Runtime}.
Additional results for E.~coli, D.~melanogaster, and two very large ($60\,\text{M}$ and $150\,\text{M}$ reads)  H.~sapiens datasets are shown in the Supplementary Data.

\subsubsection{Best-mappers}
On the C.~elegans dataset Masai was 7.7 times faster than Bowtie\,2, 8.2 times faster than BWA and 1.5 times faster than Soap\,2.
On the H.~sapiens dataset Masai was 2.6 times faster than Bowtie\,2, 3.6 times faster than BWA but 2.1 times slower than Soap\,2.
On one hand, Soap\,2 was not able to map a consistent fraction of reads because of its limitation to 2 mismatches.
On the other hand, Bowtie\,2 reported more mapped reads than Masai but, taking any-best scores into account, it reported less mapping locations than Masai.
In fact, Bowtie\,2 uses a scoring scheme based on quality values and does not impose a maximal error rate threshold.
On the C.~elegans and H.~sapiens datasets, Bowtie\,2 missed respectively 22.0\,\% and 20.7\,\% of reads mappable at edit distance 5.

%In the Rabema benchmark we pointed out that any-best scores are well correlated with recall.
%Therefore, from any-best scores we estimated that Bowtie\,2 could wrongly map up to 22.0\,\% and 20.7\,\% of reads mappable at edit distance 5 in our C.~elegans and H.~sapiens datasets. An analogous estimation can be done for BWA and Soap\,2.

\subsubsection{All-mappers}
On the C.~elegans dataset Masai was 2.0 times faster than RazerS\,3, 10.9 times faster than Hobbes, 6.3 times faster than mrFAST and 50.1 times faster than SHRiMP\,2.
Hobbes constantly crashed and mapped less reads than all other mappers in this category.
Likewise for Bowtie\,2, also SHRiMP\,2 does not impose a maximal error rate threshold and reported more mapped reads than Masai.
However its Rabema any-best score was inferior to Masai.
This could be due to the use of a different scoring scheme where two mismatches cost less than opening a gap.
Anyway this hypothesis does not explain why SHRiMP\,2 did not report some mapping locations at distance 0.

On the H.~sapiens dataset Masai was 11.9 times faster than RazerS\,3, 14.6 times faster than mrFAST, and 7.6 times faster than Hobbes. It  should be noted, that the current implementation of Hobbes often crashed and mapped only half of the reads.
SHRiMP\,2 was not able to map the H.~sapiens dataset within 4 days.

\begin{table*}[t]
  \caption[Performance on real data]{
    \label{tab:Runtime}
    \textbf{Performance on real data.}
	Results of mapping $10\,\text{M}\times 100\,\text{bp}$ Illumina reads.
	\textbf{Mapped reads.}
	In large we show the percentage of mapped reads and in small the cumulative percentage of reads that were mapped with $\bigl(\begin{smallmatrix}\mbox{\tiny 0}&\mbox{\tiny 1\%}&\mbox{\tiny 2\%}\\\mbox{\tiny 3\%}&\mbox{\tiny 4\%}&\mbox{\tiny 5\%}\end{smallmatrix}\bigr)$ errors.
	\textbf{Rabema any-best.}
    In large we show the percentage of reads mapped with the minimal number of errors (up to 5\%) and in small the percentage of reads that were mapped with $\bigl(\begin{smallmatrix}\mbox{\tiny 0}&\mbox{\tiny 1\%}&\mbox{\tiny 2\%}\\\mbox{\tiny 3\%}&\mbox{\tiny 4\%}&\mbox{\tiny 5\%}\end{smallmatrix}\bigr)$ errors.
	\textbf{Remarks.}
    SHRiMP\,2 was not able to map the H.~sapiens dataset within 4 days.
    Hobbes constantly crashed and was not able to map completely nor the C.~Elegans nor the H.~sapiens dataset.
  }
	\vspace{-3mm}
	\center
	\sffamily
	\resizebox{1.0\textwidth}{!}
	{
		\renewcommand{\tabcolsep}{0.8ex}
		\input{tables/table_masai_runtime}
	}
\end{table*}


\subsection{Filtration results}

We assessed the contribution of approximate seeds and multiple backtracking on runtime results.
To this intent we performed all-mapping with Masai on each previously considered dataset, this time using either exact or approximate seeds in combination with either single or multiple backtracking.
The optimal combination of seeding and backtracking that was used for runtime results is shown in bold.

Table\,S5 shows the results.
Filtration time consists of the time spent to index the seeds (in case of multiple backtracking) and to perform backtracking.
Candidates reports the number of candidate locations reported by the filter for which seed extension is subsequently performed.

Since we concentrate on filtration, we did not consider the time spent performing seed extensions and I/O, \ie loading the reference genome and its index, loading the reads, writing the results.
Such time is independent of any combination of seeding or backtracking and can be extrapolated by subtracting bold filtration times of Table\,S5 from respective Masai all-mappers times of Table\,3 and Table\,S4.

On E.\,coli, D.\,melanogaster and C.\,elegans approximate seeds reduce the number of candidates respectively by 2.1 times, 9.9 times, and 4.3 times.
Nevertheless we still prefer exact seeds since filtration dominates the total runtime.
Multiple backtracking on exact seeds compared to single backtracking speeds up filtration by 2.9 times on E.\,coli, and 3.8 times on D.\,melanogaster and C.\,elegans.
Without the contribution of multiple backtracking Masai would not be faster than RazerS\,3, the second fastest all-mapper.

Approximate seeds become effective on H.\,sapiens, where they reduce the number of candidates by 10.8 times. 
On H.\,sapiens seed extensions largely dominate the total runtime, therefore we prefer approximate seeds.
Multiple backtracking on approximate seeds provides a speed-up of 3.2 times over single backtracking.
The combination of the two methods makes Masai an order of magnitude faster than any other all-mapper.

\begin{table*}[h]
  \center
  \caption{
    \label{tab:Filtration}%
    \textbf{Filtration results for all-mapping.}
    Filtration time is given as [min:s] and includes seeds indexing time.
  }
  {
  \sf\footnotesize
  \begin{tabular}{llllrr}
    \toprule
	organism & dataset & seeding & backtracking & filtration time & candidates\\
    \midrule
E.\,coli & ERR022075 & exact & single & 3:55 & 69.17\,M\\
E.\,coli & ERR022075 & \textbf{exact} & \textbf{multiple} & \textbf{1:20} & \textbf{69.17\,M}\\
E.\,coli & ERR022075 & approximate & single & 38:42 & 33.08\,M\\
E.\,coli & ERR022075 & approximate & multiple & 9:00 & 33.08\,M\\
    \midrule
D.\,melanogaster & SRR497711 & exact & single & 8:15 & 1020.28\,M\\
D.\,melanogaster & SRR497711 & \textbf{exact} & \textbf{multiple} & \textbf{2:11} & \textbf{1020.28\,M}\\
D.\,melanogaster & SRR497711 & approximate & single & 100:18 & 102.78\,M\\
D.\,melanogaster & SRR497711 & approximate & multiple & 20:48 & 102.78\,M\\
    \midrule
C.\,elegans & SRR065390 & exact & single & 8:25 & 1065.70\,M\\
C.\,elegans & SRR065390 & \textbf{exact} & \textbf{multiple} & \textbf{2:11} & \textbf{1065.70\,M}\\
C.\,elegans & SRR065390 & approximate & single & 102:02 & 246.65\,M\\
C.\,elegans & SRR065390 & approximate & multiple & 21:33 & 246.65\,M\\
	\midrule
H.\,sapiens & ERR012100 & exact & single & 55:54 & 294943.86\,M\\
H.\,sapiens & ERR012100 & exact & multiple & 41:52 & 294943.86\,M\\
H.\,sapiens & ERR012100 & approximate & single & 165:45 & 27396.01\,M\\
H.\,sapiens & ERR012100 & \textbf{approximate} & \textbf{multiple} & \textbf{52:15} & \textbf{27396.01\,M}\\
    \bottomrule
  \end{tabular}
  }
  \vspace{2mm}
\end{table*}

\section{Discussion}

\subsection{Achievements}

We improved all-mapping speed by an order of magnitude.
We highlighted the importance of approximate seeds.
We adapted the algorithm to perform best-mapping.
We shown that it is better to stick to edit distance and guarantee full-sensitivity rather than adopting an involved scoring scheme and being heuristic.

\subsection{Limitations}

We realized that one best is not enough, all often is too much.

We missed very important features: paired-end or mate-pairs, mapping qualities; auto parameterization, error-rate; parallelization, low memory footprint.


% =============================================================================

\chapter{Yara}

% -----------------------------------------------------------------------------

\section{Mapping strategies}

\subsection{Single-end mapping}
\subsubsection{All-mapping}
\subsubsection{Strata-mapping}

\subsection{Paired-end mapping}
\subsubsection{All-mapping}
\subsubsection{Strata-mapping}

% -----------------------------------------------------------------------------

\section{Indexing}
\subsection{Parallelization}

% -----------------------------------------------------------------------------

\section{Evaluation}
\subsection{Rabema}
\subsection{Accuracy}
\subsection{Throughput}
\subsection{Variant calling}


% -----------------------------------------------------------------------------

\section{Discussion}

We do not consider local alignments and chimeric reads.
