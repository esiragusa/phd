\chapter{Read Mapping}

Next generation sequencing is a terrific technology.
A wealth of applications have been developed on top of it.
Data analysis pipelines for variant calling and structural variation discovery from DNA-seq, mRNA transcripts abundance estimation and novel non-coding RNA discovery from RNA-seq, transcription factor binding-sites prediction from ChIP-seq.
All these applications rely on a common prerequisite step: mapping NGS reads to a known reference genome.

Read mapping is a critical step in all NGS data analysis pipelines.
NGS reads produced by all current technologies contain sequencing errors, in form of single miscalled bases or stretches of oligonucleotides.
Moreover, the donor genome from which reads have been sequenced contains small genomic variations (SNVs, Indels) in addition to CNV, inversions and translocations.
After all, spotting genomic variation is one reason for which we resequence genomes.
Thus, when mapping a read to a reference genome, it is not sufficient to consider the loci where the reads map exactly; it is necessary to consider any loci of relevant sequence similarity, being possible origins of the sequenced reads.

% =============================================================================

\section{Sequencing technologies}
\subsection{Illumina}
\subsection{Ion Torrent}

% =============================================================================

\section{Sequencing quality}

\subsection{Phred base quality score}

Phred base quality score have been introduced in \citep{Ewing1998, Ewing1998b} to assess the quality of sequencing single bases in capillary reads.
Instead of directly discarding low-quality regions present in capillary reads, Phred calls each base and annotates it with a quality score encoding the probability that it has been wrongly called.
As this method has been widely accepted, base callers annotate reads issue of all sequencing technologies with Phred base quality scores.

To formally define Phred base quality scores, let us fix the alphabet $\Sigma = \{$ A, C, G, T $\}$, and consider a known donor genome $g$ over $\Sigma$ and a read $r$ sequenced at location $l$ from the template $g_{l \dots l+|r|-1}$.
We define the base calling error $\epsilon_i$ at position $i$ in the read $r$, as the probability $\epsilon_i = \Pr \{ r_i \neq g_{l+i-1}\}$ of miscalling a base $r_i$ instead of calling its corresponding base $g_{l+i-1}$ in the donor genome.
Therefore, we define the Phred base quality $Q_i$ at position $i$ as:
\begin{eqnarray}
Q_i = -10 \log_{10} \epsilon_i.
\end{eqnarray}

Given the above, the probability $p(r_i | g_{l+i-1})$ of calling the base $r_i$ in the read $r$, given the donor genome base $g_{l+i-1}$, is:
\begin{eqnarray}
p(r_i | g_{l+i-1}) = \left\{
\begin{array}{ll}
1-\epsilon_i                  & \text{ if } g_{l+i-1} = r_i\\
\frac{\epsilon_i}{|\Sigma|-1} & \text{ if } g_{l+i-1} \in \Sigma \setminus \{r_i\}\\
\end{array}
\right.
\end{eqnarray}
and assuming \iid base calling errors, it follows that the probability $p(r | g, l)$ of observing the read $r$, given the donor genome template $g_{l \dots l+|r|-1}$, is:
\begin{eqnarray}
\label{eq:phred}
p(r | g, l) = \prod_{i=1}^{|r|}{p(r_i | g_{l+i-1})}
\end{eqnarray}


\subsection{Mapping quality score}

Mapping quality has been introduced in \citep{Li2008}.
The study considers short reads of length ranging from 30~bp to 40~bp, produced by early Illumina/Solexa and ABI/SOLiD sequencing technologies, whose sequencing error rates were quite high.
Given the short lengths and high error rates, a significant fraction of such reads can be aligned to multiple mapping locations, even considering only co-optimal Hamming distance locations.

The key point is that the Hamming distance is not an adequate scoring scheme to guess the correct mapping location of many reads.
The authors claim\footnote{\citeauthor{Li2008} do not show in their study what is the effect of relying on mapping quality rather than on mapping uniqueness.} that:
\begin{quote}It is possible to act conservatively by discarding reads that map ambiguously at some level, but this leaves no information in the repetitive regions and it also discards data, reducing coverage in an uneven fashion, which may complicate the calculation of coverage.\end{quote}
Since base callers output base call probabilities in Phred score along with the reads, \citeauthor{Li2008} propose a novel probabilistic scoring scheme called mapping quality, giving the probability that a given read has been aligned correctly at a given mapping location in the reference genome.

By applying Bayes' theorem, we can derive the posterior probability $p(l|g,r)$, that location $l$ in the reference genome $g$ is the correct mapping location of read $r$.
Assuming uniform coverage, each location $l \in [1, |g| - |r| + 1]$ has equal probability of being the origin of a read in the donor genome, thus the prior probability $p(l)$ is simply:
\begin{eqnarray}
p(l) = \frac{1}{|g| - |r| + 1}
\end{eqnarray}
Therefore, recalling $p(r | g, l)$ from equation~\ref{eq:phred}, the posterior probability $p(l|g,r)$ equals the probability of the read $r$ originating at location $l$ normalized over all possible locations in the reference genome:
\begin{eqnarray}
\label{eq:mapprob}
p(l|g,r) = \frac{p(r|g,l)}{\sum_{i=1}^{|g| - |r| + 1}{p(r|g,i)}}
\end{eqnarray}
which in Phred-scale becomes:
\begin{eqnarray}
\label{eq:mapqual}
Q(l|g,r) = -10 \log_{10}[1 - p(l|g,r)]
\end{eqnarray}

Computing the exact mapping quality as in equation~\label{eq:mapqual} requires aligning each read to all positions in the reference genome.
On one hand, this computation would not be practical, indeed the vast majority of a reference genome is discarded when mapping reads by means of filtering and fully-indexed methods.
On the other hand, the contribution of discarded locations to the sum in equation~\ref{eq:mapprob} can be neglected.
Therefore, equation~\ref{eq:mapprob} is approximated using only relevant mapping locations found by the read mapper.

Mapping quality has been initially used in \citep{Li2008} and \citep{Li2009} to maximize variant calling confidence by discarding reads whose best mapping location is below a given mapping quality threshold.
This measure has been widely accepted: nowadays it is computed by most popular read mappers and used by almost all variant calling pipelines \eg the Genome Analysis ToolKit (GATK) \citep{DePristo2011}.

Nonetheless, some important objections can be moved against mapping quality.
First, the mapping quality score is derived under the unlikely assumption of the reference genome being equal to the donor genome.
In other words, mapping quality considers only errors due to base miscalls and disregards genetic variation; thus the risk is to prefer mapping locations supported by known low base qualities rather than by true but unknown SNVs.
Second, mapping quality is nonetheless strongly correlated to mapping uniqueness, as discussed in section~\ref{sec:mappability}; it is easy to see that the mapping probability in equation~\ref{eq:mapprob} is diluted in presence of a large number of co-optimal mapping locations.
Third, mapping quality tends to become less relevant as base calls improve, due to advances of sequencing technologies, and thus degenerates in a shallow measure of uniqueness.

% =============================================================================

\section{Genome mappability}
\label{sec:mappability}

Genome mappability has been recently studied by \citep{Derrien2012}, \citep{Lee2012}.
We start by giving our generic definition of genome mappability, analogous to \citep{Derrien2012}.

% -----------------------------------------------------------------------------

\subsection{Definitions}

\subsubsection{Mappability}

We extract a perfect read (without sequencing errors) from a reference genome, we map it back within a given distance, we count to how many loci it maps back.
Mappability at position $i$, denote by the function $M(i)$, is the inverse mapping frequency.
Any location $i$ for which $M(i) < 1$ is not unambiguously mappable.

\subsubsection{Pileup mappability}

If we focus our attention to the resequencing accuracy at a single locus, we have to consider the mappability of all the possible reads spanning that given locus.
Pileup mappability \citep{Derrien2012} at position $i$ is the average mappability of all reads spanning position $i$.

$M_p(i) = 1/q \sum_{j=i}^{i+1}{M(j)}$

\citep{Lee2012} genome mappability score (GMS) is analogous to pileup mappability.
They start by considering the mappability at position $i$ as the probability that the read ending at position $i$ can be mapped correctly.
This probability is the mapping quality.
Then, they define the $GMS(i)$ as the average probability that all reads spanning position $i$ can be mapped correctly.

\begin{center}
\input{tables/table_gms}
\end{center}

\subsubsection{Paired-end mappability}

TODO.

% -----------------------------------------------------------------------------

\subsection{Genome mappability of model organisms}

Genome mappability can bias NGS analysis more than we might think at a first glance.
By considering a reference genome of length $n$, randomly generated under the uniform bernoulli model, we would expect any string of length $log_4(n)$ to occur about once.
In the human genome almost all 17-mers would be unique, on fly 15-mers, on worm 13-mers.

Sticking to these assumptions, we would expect 36~bp reads produced by early Illumina sequencers to induce an almost perfect mappability. For two reasons, this is not the case:
\begin{itemize}
\item the $k$-mers distribution of model genomes does not fit the uniform bernoulli distribution.
In \citep{?} the $k$-mers distribution can be approximated by a double Pareto log-normal distribution, \ie a distribution with a heavy tail.
This is a result of the evolution of genomes being driven by gene duplications, retrotransposons \citep{?}

\item Reads have to be mapped approximately to the reference genome.
The expected number of approximate occurrences of a $k$-mer is higher than the exact one.
Thus the above estimate is a lower bound.
\end{itemize}

% -----------------------------------------------------------------------------

\subsection{The Uniqueome}

\citep{Derrien2012} quantified the whole genome unique mappability for human, mouse, fly, and worm.
At a $(36,2)$ mapping, about 30~\% of the human genome is not uniquely mappable.
Unique mappability rises to 83~\% by increasing the read length to 75~bp; however to map a significant fraction of the reads, we should consider 3--4 edit distance errors.

\begin{center}
\input{tables/table_mappability}
\end{center}

The uniqueome plays an important role in ChIP-seq experiments.
It is common practice \citep{?} to rely on short (36~bp) reads and discard the non-unique ones.
Not only a significant fraction of the sequencing data is thrown out.
Worse than that, we end up with holes in 30~\% of the genome.
A ChIP-seq peak caller considering multi-reads calls up to 30~\% more peaks.

Cite regions of clinical relevance, \eg HLA-A.
Cite regions of biological relevance, \eg 5S rRNA.


% =============================================================================

\section{Classification of read mappers}

\subsection{Surveys}

Cite tens of surveys classifying hundreds of mappers.
\citep{Li2010}, \citep{Fonseca2012}.

Critic the surveys.
Critic the mappers.

\subsection{Benchmarks}

\citep{Hatem2013} \citep{Holtgrewe2011}

% -----------------------------------------------------------------------------

\subsection{Best mappers versus all mappers}

The task of a read mapper is to guess where a read originates.
Fixed a similarity scoring scheme that confidently models this problem, the optimal alignment under this scoring scheme correspond to the most likely explanation and induces a locus being the origin of the read.
The simplest scoring scheme is the edit distance; more involved scoring schemes take into account base quality values, score gaps using affine cost functions, or allow to trim for free a prefix or a suffix of the read.

The above definition does not consider two problems: what if there are many co-optimal candidates, and what if the correct solution corresponds to a sub-optimal candidate.
The former problem is exacerbated by genome mappability.
One would expect such situations to arise very rarely, but instead it is a relevant problem.
The latter problem arises whenever our model is not adequate to explain the difference between a read and its genomic origin.
For instance, an evolutionary event producing an indel of length $l$ might be considered as a unit, whether edit distance would consider it as $l$ independent events.
Under the edit distance, an alignment with less than $l$ independent point mutations would be considered more likely than an alignment containing only one indel of length $l$.

From the former problem, we conclude that considering only one optimal mapping location is not sufficient, no matter how good our scoring scheme can be.
The latter problem tells us to be careful about relying on strict optimality.
Therefore, in general a read mapper should return a comprehensive set of relevant mapping locations along with the likelihood that they correspond to the original location.

% =============================================================================

\section{Read mappers}

% -----------------------------------------------------------------------------

\subsection{Bowtie}

Bowtie \citep{Bowtie} is a mapper designed to have a small memory footprint and quickly report a few good mapping locations for early generation Illumina/Solexa and ABI/SOLiD short reads of length up to 50~bp.
It achieves the former goal by indexing the reference genome with an FM-index and the latter goal by performing a greedy depth-first traversal on it.

The greedy depth-first traversal visits first the subtree yielding the least number of mismatches and stops after having found a candidate (not guaranteed to be optimal when $k>1$).
In addition, Bowtie speeds up backtracking by applying case pruning, a simple application of the pigeonhole principle.
However this technique is mostly suited for $k=1$ and requires the index of the forward and reverse text.

Bowtie can be configured to search by strata, however the search time increases significantly while the traversal still misses a large fraction of the search space due to seeding heuristics.
Main practical drawbacks of the tool are too many cryptic options.

Bowtie~2 \citep{Bowtie2} has been designed to quickly report a couple of mapping locations for recent Illumina/Solexa, Ion Torrent and Roche/454 reads, usually having lengths in the range from 100~bp to 400~bp.

This tool uses an heuristic seed-and-extend approach, collecting seeds of fixed length, partially overlapping, and searching them exactly in the reference genome using an FM-index.
Candidate locations to verify are chosen randomly, to avoid uncompressing large CSA intervals and executing many DP instances.
Each mapping location is verified using a striped vectorial dynamic programming algorithm, implemented using SIMD instructions, previously introduced by \citep{Farrar2007} and extended to compute end-to-end alignments.

Bowtie~2 can be configured to report end-to-end or local alignments, scored using a tunable affine scoring scheme.
For this reason, it is believed to be good at reporting alignments containing indels.
However, its completely heuristic filtration strategy, independent of the scoring scheme, makes it hard to believe what it promises.

% -----------------------------------------------------------------------------

\subsection{BWA}

BWA-backtrack \citep{BWA} is designed to map Illumina/Solexa reads up to 100~bp and report a few best end-to-end alignments.
The program performs a greedy breadth-first search on an FM-index of the reference genome.
Nodes to be visited are ranked by edit distance score: the best node is popped from a priority queue and visited, its children are then inserted again in the queue.
The traversal considers indels using a more involved 9-fold recursion.
Backtracking is sped up by adopting a more stringent pruning strategy that nonetheless takes some preprocessing time and requires the index of the reverse reference genome.

BWA performs paired-end alignments by trying to anchor both paired-end reads and verifying the corresponding mate, within an estimated insert size, using the classic DP-based Smith-Waterman algorithm.
Consequently, the program in paired-end mode aligns reads at a slower rate than in single-end mode.
The program is not fully multi-threaded, therefore BWA scales poorly on modern multi-core machines.

BWA-SW \citep{BWA-SW} is designed to map Roche/454 reads, which have an average length of 400~bp.
It is an heuristic version of BWT-SW, designed to report a few good local alignments.

This version of BWA adopts a double indexing strategy: it indexes all substrings of one read in a DAWG.
It performs Smith-Waterman of all read substrings directly on the FM-index, by backtracking as soon as no viable alignment can be obtained.
As in BWA-backtrack, the traversal proceeds in a greedy fashion.
In addition, BWA-SW implements some seeding heuristics to limit backtracking and jump in the reference genome to verify candidate locations whenever this becomes favorable.

This version of BWA does not support paired-end reads, presumably because it was meant for Roche/454 reads.

% -----------------------------------------------------------------------------

\subsection{Soap}

Soap~2 \citep{Soap2} is very similar to Bowtie: it has been designed to produce a very quick but shallow mapping of Illumina/Solexa reads up to 75~bp with no more than 2 mismatches and no indels.
However, its underlying algorithm is based on the so-called bi-directional (or 2-way) BWT.
The tool support paired-end mapping but at a slower alignment rate.
Practical drawbacks are the lack of native output in the de-facto standard SAM format and is closed source.
Soap~3 \citep{Soap3} is algorithmically similar to Soap~2 but targets only NVIDIA CUDA accelerators.

% -----------------------------------------------------------------------------

\subsection{SHRiMP}

SHRiMP~2 TODO.

% -----------------------------------------------------------------------------

\subsection{RazerS}

RazerS \citep{Weese2009} has been designed to report all mapping locations within a fixed hamming or edit distance error rate.
It is based on a full-sensitive $q$-gram filtration method (SWIFT semi-global) combined with the Myers edit distance verification algorithm.
On demand, the SWIFT filter can be configured to become lossy within a fixed loss rate.
The lossy filter becomes more stringent and produces a lower number of candidates to verify, thus improving the overall speed of the program.
All in all, the SWIFT filter is very slow while not highly specific.

RazerS~3 \citep{RazerS3} is a faster version featuring shared-memory parallelism, a faster banded-Myers verification algorithm, and a faster filtration scheme based on exact seeds that however turns out to be very weak on mammal genomes.
Because of this, RazerS~3 is one-two orders of magnitude slower than Bowtie~2 and BWA-backtrack on mammal genomes.

All RazerS versions index the reads and scan the reference genome.
One positive aspect of this strategy is that no preprocessing of the reference genome is required.
However, other mapping strategies beyond all-mapping, \eg mapping by strata, cannot be efficiently implemented.
Moreover, the program exhibit an high memory footprint as it must remember the mapping locations of all input reads until the whole reference genome has been scanned.

% -----------------------------------------------------------------------------

\subsection{mr(s)Fast}

The tools mrFast \citep{Ahmadi2011} and mrsFast \citep{Hach2010} are designed to report all mapping locations within a fixed absolute number errors, respectively under the hamming and edit distance, given Illumina/Solexa reads of length ranging from 50~bp to 125~bp.
Similarly to RazerS~3, they are based on a full-sensitive filtration strategy using exact seeds, which turns out to be very weak on mammal genomes.

The peculiarity of their underlying method is a cache-oblivious strategy to mitigate the high cost of verifying clusters of candidate locations.
In addition, mrsFast computes the edit distance between one read and one mapping location in the reference genome with an antidiagonal-wise vectorial dynamic programming algorithm, implemented using SIMD instructions.

These tools are as slow as RazerS~3 and appealing for nothing more than all-mapping.
They lack multi-threading support and exhibit various bugs.
Furthermore, they only accept reads of fixed length and produce files of impractical size.

% -----------------------------------------------------------------------------

\subsection{GEM}

The GEM mapper \citep{Gem} is a flexible read aligner for Illumina/Solexa, ABI/SOLiD, and Ion Torrent reads.
It is full-sensitive and can be configured either as an all-mapper, as a best/unique-mapper, or to search by strata.

GEM uses a combination of state of the art approximate string matching methods, \eg approximate seeds and suffix filters.
The program indexes the reference genome with an FM-index, tries to find an optimal filtration strategy per read, and verifies candidate locations using Myers algorithm.
Paired-reads are either mapped independently and then combined, or left/right are mapped and their mates verified using an online strategy.

Unfortunately the tool lacks direct SAM output, it is not open source, and provides many obscure parameters.

\begin{landscape}
\begin{table}[h]
  \center
  \sffamily
%  \resizebox{1.0\textwidth}{!}
%  {
	\renewcommand{\tabcolsep}{0.8ex}
	\input{tables/table_mappers}
%  }
\end{table}
\end{landscape}

% =============================================================================

\section{Masai}

% -----------------------------------------------------------------------------

\subsection{Single-end mapping}

\subsubsection{All-mapping}
\subsubsection{Mapping by strata}

\subsection{Paired-end mapping}

% =============================================================================

\section{Yara}

% -----------------------------------------------------------------------------

\subsection{Single-end mapping}
\subsubsection{All-mapping}
\subsubsection{Mapping by strata}

% -----------------------------------------------------------------------------

\subsection{Paired-end mapping}
\subsubsection{All-mapping}
\subsubsection{Mapping by strata}

% -----------------------------------------------------------------------------

\subsection{Parallelization}
\subsection{Hardware acceleration}

% =============================================================================

\section{Assessment of read mappers performance}
\subsection{Comparison of filtration strategies}
\subsection{Rabema benchmark results}
\subsection{Variant detection results}
\subsection{Runtime results}

% =============================================================================

\section{Discussion}

