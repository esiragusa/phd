\chapter{Background}

% === Introduction ===

\section{Introduction}

% --- Motivation ---

\subsection{Motivation}
%\subsection{History of sequencing}

This work has been motivated by recent advances of molecular genetics.
The human genome has been sequenced in 2001. Also mouse, drosophila, etc.
Nowadays \# reference model genomes are available in genbank.

Next-generation sequencing has been the second revolution.
NGS produces billions of reads for 1000\$ dollars.
Why should one re-sequence a known genome?
Resequencing applications include variant calling, etc.
So NGS impacts biomedicine.

Given a set of reads, two approaches are possible: assembly and mapping.

Assembly methods are based on overlaps, de brujin graphs, or...

Read mapping methods work on a previously assembled reference genome.

The typical SNPs analysis pipeline \ref{fig:ngs-pipeline} consists of...

In this work we focus on read mapping, although many core algorithms considered are also applicable to assembly, as well as to later pipeline stages.

\begin{figure}[h]
\caption{NGS pipeline.}
\label{fig:ngs-pipeline}
\end{figure}

% --- Problem definition ---

\subsection{Fundamentals}

\subsubsection{Fundamental definitions}

Let us start by defining primitive objects of stringology: alphabets and strings. An alphabet is a finite set of symbols (or characters); a string (or word) over an alphabet is a finite sequence of symbols from that alphabet. We denote the length of a string $s$ by $\left| s \right|$, and by $\epsilon$ the empty string s.t. $\left| \epsilon \right|=0$.
Given an alphabet $\Sigma$, we define $\Sigma^0=\{ \epsilon \}$ as the set containing the empty string, $\Sigma^n$ as the set of all strings over $\Sigma$ of length $n$, and $\Sigma^* = \cup_{n=0}^{\infty}{\Sigma^n}$ as the set of all strings over $\Sigma$. Finally, we call any subset of $\Sigma^*$ a language over $\Sigma$.

We now define concatenation, the most fundamental operation on strings. The concatenation operator of two strings is denoted with $\cdot$ and defined as $\cdot : \Sigma^* \times \Sigma^* \rightarrow \Sigma^*$. Given two strings, $x \in \Sigma^n$ with $x=\alpha_1\alpha_2\dots\alpha_n$, and $y \in \Sigma^m$ with $y=\beta_1\beta_2\dots\beta_m$, their concatenation $x \cdot y$ (or simply denoted $xy$) is the string $z \in \Sigma^{n+m}$ consisting of the symbols $\alpha_1\alpha_2\dots\alpha_n\beta_1\beta_2\dots\beta_m$.

From concatenation we can derive the notion of prefix, suffix, and substring.
A string $x$ is a prefix of $y$ iff there is some string $z$ s.t. $y=x\cdot z$.
Analogously, $x$ is a suffix of $y$ iff there is some string $z$ s.t. $y=z\cdot x$.
Similarly, $x$ is a substring of $y$ iff there is some string $w,z$ s.t. $y=w\cdot x \cdot z$.
Moreover, if $x$ is a substring of $y$, then we say that $x$ occurs within $y$ at position $|w|$.

For example, let us consider the alphabet $\Sigma$ consisting of DNA bases: $\Sigma = \{A,C,G,T\}$. Examples of strings over $\Sigma$ are $x=A$, $y=AGGTAC$, $z=TA$. For instance, $y \in \Sigma^6$ and $\left| y \right| = 6$. An example of concatenation is $x \cdot z = ATA$. The string $x$ is a prefix of $y$. The string $z$ is a substring of $y$, occurring at position 4 in $y$.

\subsubsection{Fundamental problems}

We now define exact string matching, the most fundamental problem in stringology.
Given a string $p$ called the pattern and a longer string $t$ called the text, the exact string matching problem is to find all occurrences, if any, of pattern $p$ into text $t$ \cite{Gusfield1997}.

This problem can be generalized in various ways. For instance, the definition of distance between strings yields approximate string matching.


Define distance between two strings.
Let $d$ be a distance function over words, defined as $d : (\Sigma^{*}, \Sigma^{*}) \rightarrow \mathcal{N}$.
Common distance metrics are the Hamming and Levenshtein or edit distance.

$d_H = $

$d_E = $

Define alignment between two strings.


Define occurrence.
We say that a word $p$ of length $m$ occurs in another word $t$ at position $e$ if $t_{e-m, e} = p$.
The notion of occurrence can be generalized to metric distances...

Define approximate string matching.
Given two words $t$ and $p$ such that $t \gg p$, respectively called text and pattern. Given a distance threshold $k \in \mathcal{N}$.
The approximate string matching problem is to find all occurrences of $p$ into $t$ within the error threshold $k$.

These definitions allow us to model basic biological.


% === Overview of existing methods ===

\section{Overview of existing methods}

Existing methods can be classified in three categories: online, indexed and filtering.
Online and filtering in \cite{Navarro1998}. Indexed in \cite{Navarro2001}.

% --- Online methods ---

\subsection{Online methods}

\subsubsection{Dynamic Programming}

The edit distance between two strings can be efficiently computed via dynamic programming.

The recurrence relation is as follows: $D[i,j] = \dots$

Answering the question whether the distance $d(x,y) \leq k$ is an easier problem: a band of size $k+1$ is sufficient.

Finding all occurrences of a pattern $p$ in a text $t$...

Change initialization.

Change traceback to start from all $j : D[m,j] \leq k$.


\subsubsection{DP Bit-parallelism}


\subsubsection{Automata}

\subsubsection{NFA}


% --- Indexed methods ---

\subsection{Indexed methods}

\subsubsection{Suffix tree}

\subsubsection{Backtracking}

% --- Filtering methods ---

\subsection{Filtering methods}

\subsubsection{Why filtering}

\subsubsection{Pigeonhole principle}

\subsubsection{$q$-Gram lemma}

% === Related problems ===

\section{Related problems}

% --- Local similarity search ---

\subsection{Local similarity search}

Define score and scoring scheme.

Define local similarity.

\subsubsection{Online methods}
Give dynamic programming solution.

\subsubsection{Indexed methods}
Backtracking over substring index. BWT-SW.

\subsubsection{Filtering methods}
SWIFT/Stellar is based on the q-gram lemma.
Lastz resembles a suffix filter.


% --- Dictionary search ---

\subsection{Dictionary search}

Define problem.

\subsubsection{Trie}

\subsubsection{Backtracking}

% --- Overlaps computation ---

\subsection{Overlaps computation}

Define problem.

DP solution.

Indexed solution, exact and approximate.

